{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Django Async Framework","text":"<p>Django Async Framework is a lightweight class-based view framework built on top of Django.</p> <p>Django is a powerful web framework, but its async support is still a work in progress. Some parts play well with async, others don\u2019t. Django Async Framework aims to fill in those gaps by giving a fully async-first way to build with Django.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Install it with pip:</li> </ol> <pre><code>pip install djangoasyncframework\n</code></pre> <ol> <li>Add it to your <code>INSTALLED_APPS</code> in <code>settings.py</code>:</li> </ol> <pre><code>INSTALLED_APPS = [\n    # your other apps...\n    'async_framework',\n]\n</code></pre>"},{"location":"#why-this-matters","title":"Why This Matters","text":"<p>Django deserves a modern async-first ecosystem, not just patches around old sync components. It provides a structured foundation for writing asynchronous code in Django without relying on sync-based workarounds.</p>"},{"location":"#project-status","title":"Project Status","text":"<p>This is an early-stage open-source project that\u2019s still growing. We\u2019d love your feedback, ideas, bug reports, and contributions.</p> <p></p> <p>Stay tuned, Djangonauts \u2764\ufe0f</p>"},{"location":"about/","title":"About","text":"<p>Django Async Framework is an open-source Python package that brings first-class asynchronous support to Django\u2019s class based views, enabling developers to write fully async HTTP handlers with simple base classes and utilities.</p>"},{"location":"about/#license","title":"License","text":"<p>Django Async Framework is released under the BSD 3-Clause License, a permissive open-source license that allows you to freely use, modify, and distribute the software with minimal restrictions. See the LICENSE file for details.</p>"},{"location":"about/#contributing","title":"Contributing","text":"<p>Contributions are welcome! Whether you want to report bugs, request features, improve documentation, or submit code patches, your help is appreciated.</p>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#1-installation","title":"1. Installation","text":"<p>Install Django Async Framework from PyPI:</p> <pre><code>pip install djangoasyncframework\n</code></pre> <p>Then, add it to your Django <code>INSTALLED_APPS</code> in <code>settings.py</code>:</p> <pre><code>INSTALLED_APPS = [\n    # ...\n    \"async_framework\",\n]\n</code></pre>"},{"location":"quickstart/#2-create-your-first-async-api-view","title":"2. Create Your First Async API View","text":"<p>Create a new Django view using <code>AsyncAPIView</code>:</p> <pre><code>from async_framework.views.api import AsyncAPIView\n\nclass HelloWorldView(AsyncAPIView):\n    async def get(self, request):\n        return self.success({\"message\": \"Hello from async!\"})\n</code></pre> <p>This defines a fully async compatible GET view that returns a simple JSON response.</p>"},{"location":"quickstart/#3-add-the-view-to-your-urls","title":"3. Add the View to Your URLs","text":"<p>In your <code>urls.py</code>:</p> <pre><code>from django.urls import path\nfrom .views import HelloWorldView\n\nurlpatterns = [\n    path(\"hello/\", HelloWorldView.as_view()),\n]\n</code></pre>"},{"location":"quickstart/#4-try-it-out","title":"4. Try It Out","text":"<p>Run your Django development server:</p> <pre><code>python manage.py runserver\n</code></pre> <p>Then go to: http://localhost:8000/hello/</p> <p>You should see:</p> <pre><code>{\n  \"message\": \"Hello from async!\"\n}\n</code></pre>"},{"location":"quickstart/#whats-next","title":"What\u2019s Next?","text":"<p>Want to explore more features? Check out the tutorial.</p>"},{"location":"tutorial/async_error_middleware/","title":"async_error_middleware","text":"<p><code>async_error_middleware</code> is a middleware designed to catch exceptions in both synchronous and asynchronous views, returning a JSON response instead of the default HTML error page.</p>"},{"location":"tutorial/async_error_middleware/#example-usage","title":"Example Usage","text":"<p>To use the middleware, add it to your Django <code>settings.py</code>:</p> <pre><code>MIDDLEWARE = [\n    # other middleware\n    'async_framework.middleware.async_error_middleware',\n]\n</code></pre> <p>View that raises an exception:</p> <pre><code>from django.http import JsonResponse\n\nasync def my_async_view(request):\n    raise ValueError(\"Something went wrong\")\n</code></pre> <p>Resulting JSON response:</p> <pre><code>{\n  \"error\": \"Something went wrong\",\n  \"type\": \"ValueError\",\n  \"trace\": \"Traceback (most recent call last):\\n  File ... \\nValueError: Something went wrong\"\n}\n</code></pre>"},{"location":"tutorial/async_task/","title":"async_task","text":"<p>The <code>@async_task</code> decorator and <code>AsyncTask</code> class provide a simple, lightweight in-memory async task queue system designed to help scheduling asynchronous functions to run in the background without blocking the main request/response cycle.</p> <p>This system supports:</p> <ul> <li>Scheduling async functions to run later (fire-and-forget style)</li> <li>Optional retrying on failure, with configurable retry count</li> <li>Optional delay before task execution</li> <li>Automatic background worker that processes tasks asynchronously</li> </ul> <p>You could use this function when your application performs time-consuming async operations such as sending emails, calling external APIs, or processing data and you don\u2019t want to block the user\u2019s request and make them wait.</p>"},{"location":"tutorial/async_task/#example-usage","title":"Example Usage","text":"<pre><code>from async_framework.tasks import async_task\n\n@async_task(retries=1, delay=1.5)\nasync def heavy_operation(user_id):\n    print(f\"Starting heavy operation for user {user_id}\")\n    await asyncio.sleep(2)\n    print(f\"Completed heavy operation for user {user_id}\")\n\n# Schedule task to run in background\nheavy_operation.delay(123)\n\n# Continue handling request without waiting\n</code></pre> <ul> <li><code>retries</code> (int): Number of times to retry on failure (default 0)</li> <li><code>delay</code> (float): Delay in seconds before running the task (default 0)</li> </ul>"},{"location":"tutorial/async_task/#scheduling-tasks","title":"Scheduling Tasks","text":"<p>Call the <code>.delay()</code> method on the decorated function to schedule the task asynchronously:</p> <pre><code>send_welcome_email.delay(42)\n</code></pre> <p></p> <p>Notes: * Currently, the queue is in-memory and single-process, meaning tasks are lost if the app restarts and no distributed processing is supported. * Suitable for lightweight async tasks or during early development. * Future plans may include persistent queues, task logging and tracking, and multi-worker support.</p>"},{"location":"tutorial/asyncapiview/","title":"AsyncAPIView","text":"<p><code>AsyncAPIView</code> is a base class for creating asynchronous API views, built on top of <code>AsyncView</code>. It helps handling async HTTP requests with JSON payload parsing, success/error JSON responses, and optional async throttling support.</p>"},{"location":"tutorial/asyncapiview/#example-usage","title":"Example Usage","text":"<pre><code>from async_framework.views.api import AsyncAPIView\n\nclass MyAsyncAPIView(AsyncAPIView):\n    async def post(self, request):\n        data = request.data\n        # Perform async operations here\n        return self.success({\"echo\": data})\n</code></pre>"},{"location":"tutorial/asyncapiview/#how-does-it-work","title":"How Does It Work?","text":"<ol> <li>For mutating HTTP methods (<code>POST</code>, <code>PUT</code>, <code>PATCH</code>), it reads and parses the JSON request body asynchronously.</li> <li>If throttling is enabled by setting the <code>throttle</code> attribute, the view will await the throttle's <code>allow_request</code> method. If the request is blocked, a 429 error is returned.</li> <li>Otherwise, it delegates to the async method handler (like <code>post</code>, <code>get</code>, etc.) implemented by the subclass.</li> <li>The <code>success</code> and <code>error</code> methods simplify returning JSON responses with consistent formatting.</li> </ol>"},{"location":"tutorial/asyncratethrottle/","title":"AsyncRateThrottle","text":"<p><code>AsyncRateThrottle</code> is a simple asynchronous rate-limiting utility designed for use with async views. It allows restricting the number of requests a client can make within a specified time window.</p>"},{"location":"tutorial/asyncratethrottle/#example-usage","title":"Example Usage","text":"<pre><code>from async_framework.throttle import AsyncRateThrottle\nfrom async_framework.views.api import AsyncAPIView\n\nclass AsyncRateThrottleView(AsyncAPIView):\n    throttle = AsyncRateThrottle(rate='5/second') # Time units supported: second, minute, and hour\n\n    async def get(self, request):\n        if not await self.throttle.allow_request(request):\n            return self.error(\"Rate limit exceeded\", status=429)\n        return self.success({\"msg\": \"Allowed!\"})\n</code></pre>"},{"location":"tutorial/asyncratethrottle/#how-does-it-work","title":"How Does It Work?","text":"<ol> <li>You instantiate it with a rate string like <code>'10/minute'</code>.</li> <li>The rate is parsed into a number of requests and a time duration in seconds.</li> <li>For each request, it fetches the client identifier (defaulting to the remote IP).</li> <li>It removes timestamps older than the current window from its in-memory history.</li> <li>If the number of requests within the window exceeds the allowed number, it rejects the request.</li> <li>Otherwise, it records the current request time and permits the request.</li> </ol> <p>Important Note: The throttle uses an in-memory dictionary to store request history, so it works best in single-process environments. For multi-process or distributed deployments, a shared cache or database-backed throttle would be necessary.</p>"},{"location":"tutorial/asyncview/","title":"AsyncView","text":"<p><code>AsyncView</code> is the foundation of the Async framework. It currently performs three main jobs:</p> <ol> <li>Enforces <code>async def</code>: All your HTTP method handlers (<code>get</code>, <code>post</code>, etc.) must be asynchronous. This protects the event loop and ensures your views are non-blocking.</li> <li>Provides an <code>async_setup()</code> hook: Runs once before the HTTP handler. Use it to preload data, inject context, or run per-request async logic that multiple handlers can share.</li> <li>Supports services dependency injection: Define a <code>services</code> dictionary (or override the <code>services_attr</code>) to register per-request service factories. These are resolved once per request and attached to your view instance, keeping your code clean and DRY.</li> </ol>"},{"location":"tutorial/asyncview/#example-usage","title":"Example Usage","text":"<pre><code>from async_framework.views.core import AsyncView\nfrom django.http import JsonResponse\n\nclass MyAsyncView(AsyncView):\n    services = {\n        \"analytics\": lambda: AnalyticsService(),\n    }\n\n    async def async_setup(self, request, *args, **kwargs):\n        self.user_data = await load_user_data_async(request.user)\n\n    async def get(self, request):\n        report = await self.services[\"analytics\"].generate_report(self.user_data)\n        return JsonResponse({\"report\": report})\n</code></pre>"},{"location":"tutorial/asyncview/#how-does-it-work","title":"How Does It Work?","text":"<ol> <li>Overrides <code>dispatch()</code> to fully support <code>async def</code> methods.</li> <li>Validates that the handler (e.g., <code>get</code>, <code>post</code>) is asynchronous. If not, it raises a <code>TypeError</code>.</li> <li>Awaits <code>async_setup()</code> to perform any per-request async initialization (optional).</li> <li>Resolves all defined services in <code>self.services</code> using their factory functions. These can be sync or async.</li> <li>Finally, awaits the actual handler method.</li> </ol> <p>This pattern keeps your views minimal, safe, and composable \u2014 and allows clean injection of services, like logging, analytics, business logic, or database wrappers.</p>"},{"location":"tutorial/await_safe/","title":"await_safe","text":"<p>In an async Django view, calling blocking code like <code>MyModel.objects.get(...)</code> directly can block the event loop.</p> <p><code>await_safe</code> is a utility function to safely run blocking synchronous code such as Django ORM calls inside asynchronous views or functions.</p>"},{"location":"tutorial/await_safe/#example-usage","title":"Example Usage","text":"<pre><code>from async_framework.orm import await_safe\n\nasync def get_user(request):\n    user = await await_safe(MyModel.objects.get)(id=5)\n    return JsonResponse({\"username\": user.username})\n</code></pre>"},{"location":"tutorial/await_safe/#chained-orm-method","title":"Chained ORM Method","text":"<pre><code>async def view(request):\n    first_item = await await_safe(MyModel.objects.filter(active=True).first)()\n    return JsonResponse({\"name\": first_item.name})\n</code></pre>"},{"location":"tutorial/await_safe/#how-does-it-work","title":"How does it work?","text":"<p><code>await_safe(callable)</code> wraps the function with:</p> <pre><code>sync_to_async(callable, thread_sensitive=True)\n</code></pre> <p>This shifts the execution to a thread pool, preserving thread safety in Django\u2019s ORM.</p>"},{"location":"tutorial/run_in_background/","title":"run_in_background","text":"<p><code>run_in_background</code> is a simple yet essential utility function designed to help running asynchronous tasks in the background. It provides a fire-and-forget mechanism for coroutine functions to trigger async operations that run concurrently alongside the application.</p> <p>This function is one of the core building blocks of the Async Framework, but it is still in its early stages of development. At present, it focuses on the core functionality of launching background async tasks with basic error handling. Future versions may introduce advanced capabilities.</p>"},{"location":"tutorial/run_in_background/#example-usage","title":"Example Usage","text":"<pre><code>from async_framework.utils import run_in_background\n\nasync def send_welcome_email(user_id: int):\n    await some_async_email_service.send(user_id)\n\ndef user_signup(user_data):\n    new_user_id = create_user_in_db(user_data)\n\n    # send welcome email in background without waiting\n    run_in_background(send_welcome_email, new_user_id)\n\n    return \"Signup complete!\"\n</code></pre> <p>Note: Since <code>run_in_background</code> does not wait for or monitor the completion of the task it starts, it\u2019s not suitable for use cases where you need to track results or handle complex error recovery.</p>"}]}